<!DOCTYPE html>
<html lang="en">
<head lang="en">
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <link rel="icon" href="favicon.ico" sizes="any"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" crossorigin="anonymous"/>
    <link rel="stylesheet" href="style.css"/>
    <title>Yurii Cherkasov CV</title>
</head>
<body>
<header>
    <nav class="top-nav" aria-label="Primary">
        <a class="top-nav__item" href="./index.html">About</a>
        <a class="top-nav__item" href="./cv.html">My CV</a>
        <a class="top-nav__item" href="./blog.html">Blog</a>
        <a class="top-nav__item" href="contact.html">Contacts</a>
    </nav>
    <div id="avatar-container">
        <img src="images/avatar.jpg" alt="Profile photo"/>
    </div>
    <h1>Yurii Cherkasov</h1>
    <p class="latin-quote">Verba volant scripta manent</p>
    <section id="header-social">
        <a href="https://www.linkedin.com/in/yurii-cherkasov-653b213a0/" target="_blank" rel="noopener noreferrer">
            <i class="fab fa-linkedin-in"></i>
        </a>
        <a href="https://github.com/yuchdev" target="_blank" rel="noopener noreferrer">
            <i class="fab fa-github-alt"></i>
        </a>
        <a href="https://www.facebook.com/yuchdev" target="_blank" rel="noopener noreferrer">
            <i class="fab fa-facebook-f"></i>
        </a>
        <a href="https://x.com/yuchdev" target="_blank" rel="noopener noreferrer">
            <i class="fab fa-x-twitter"></i>
        </a>
        <a href="https://www.instagram.com/yuchdev" target="_blank" rel="noopener noreferrer">
            <i class="fab fa-instagram"></i>
        </a>
    </section>
</header>

<main>
    <section id="container">
        <div class="section">
            <h2>Latest post (placeholder)</h2>
            <article>
                <h3>General C++ Knowledge</h3>
                <p>
                    In continuation of the discussion about C++ interview practices, a recurring question inevitably
                    arises: <em>what exactly is “general C++ knowledge”?</em> Is it truly important when hiring an
                    engineer, and if so, how can it be evaluated in a meaningful way?
                </p>
                <p>
                    When we speak about “good”, “excellent”, or even “outstanding” C++ knowledge, we are rarely talking
                    about a single, linear skill set. In practice, C++ expertise is a conglomerate of several weakly
                    intersecting domains. The classification below is subjective, but it reflects what years of
                    real-world development and interviewing tend to reveal. You may extend it, refine it, or construct
                    your own model.
                </p>
                <h4>1. C-legacy and low-level subset</h4>
                <p>
                    This subset covers the foundations inherited from C and extended by C++: fundamental types, memory
                    layout, pointer arithmetic, alignment, and object lifetimes. It also includes C++-specific low-level
                    concepts such as references and rvalue references, <code>new</code>/<code>delete</code>/<code>delete[]</code>,
                    custom memory managers, allocators, and ownership semantics. These topics form the bedrock of
                    performance-critical and systems-level code.
                </p>
                <h4>2. Object-Oriented Programming subset</h4>
                <p>
                    Classes, encapsulation, inheritance, virtual functions, and polymorphism live here - along with
                    design patterns and their corresponding anti-patterns. This is also where developers encounter the
                    notorious complexities of multiple and virtual inheritance. Understanding not only <em>how</em> OOP
                    works in C++, but <em>when it should not be used</em>, is part of mature knowledge.
                </p>
                <h4>3. Template programming and metaprogramming subset</h4>
                <p>
                    Claiming competence here means more than knowing template syntax. It implies understanding both the
                    power and the cost of template metaprogramming. My personal motto is simple: <em>“templates are for
                    libraries”</em>. A professional should be able to write advanced template code when necessary - and,
                    just as importantly, resist the temptation to use it where it harms readability and maintainability.
                </p>
                <h4>4. C++ Standard Library subset</h4>
                <p>
                    Containers, iterators, algorithms, and utilities form the daily toolkit of modern C++. This includes
                    not only the classical components, but also newer additions such as ranges, filesystem support, and
                    concurrency primitives. Knowing how to compose standard algorithms effectively often separates
                    idiomatic C++ from merely functional code.
                </p>
                <h4>5. Multithreading and concurrency subset</h4>
                <p>
                    This domain spans lock-based and lock-free programming, atomics, memory ordering, <code>async</code>,<code>future</code>/<code>promise</code>,
                    and the common pitfalls of concurrent execution - from data races to the ABA problem. More than any
                    other area, this requires a specific “multithreaded mindset”: knowing when parallelism is essential,
                    and when it should be deliberately avoided.
                </p>
                <h4>6. Compilation, optimization, and performance subset</h4>
                <p>
                    Here the focus shifts to how code becomes machine instructions. Familiarity with compiler
                    toolchains, optimization levels, architecture-specific flags, and tools like Compiler Explorer is
                    essential. A senior engineer should be comfortable reading basic assembly output, understanding
                    cache behavior, vectorization, and CPU extensions, and making informed decisions about performance
                    trade-offs.
                </p>
                <p>
                    Importantly, no one expects encyclopedic or “book-perfect” knowledge. What <em>is</em> expected is
                    the ability to acknowledge gaps and efficiently close them. When encountering an unfamiliar language
                    feature, a professional C++ developer should be able to locate accurate information within minutes -
                    and apply it correctly.
                </p>
                <p>
                    A senior C++ engineer cannot afford to have zero knowledge in any of these subsets. One weaker area
                    may be acceptable; two weak areas are already a red flag and require careful evaluation of the
                    candidate's other strengths. Concurrency, in particular, is not something one can acquire by
                    skimming documentation for an hour - it is a “twilight zone” that demands months of experience,
                    mistakes, and hard-earned understanding.
                </p>
                <p>
                    This discussion deliberately focuses on the C++ language itself. Libraries such as Boost are
                    intentionally omitted: they often span multiple subsets, from everyday utilities to highly
                    specialized components like Spirit or Karma.
                </p>
                <p>
                    Likewise, applied and system-level aspects are excluded here. In real projects, language knowledge
                    is often paired with platform-specific APIs, operating-system concepts, or frameworks such as Qt,
                    which introduce their own abstractions, memory models, and lifecycle rules.
                </p>
                <p>
                    This, then, is what I consider general C++ knowledge - knowledge that a professional C++ developer
                    must possess. The word “must” is not theoretical; it is based on day-to-day engineering experience.
                    The difference between a developer whose pull requests are a pleasure to review and one whose
                    changes are repeatedly rejected often lies precisely in these fundamentals.
                </p>
                <p>
                    When we speak of truly outstanding C++ engineers, the distinction is not merely depth in individual
                    areas, but an understanding of the subtle interconnections between them. Knowing when templates
                    undermine encapsulation, what hazards arise when overloading <code>operator new</code>, or how to
                    design a genuinely STL-compatible container with proper exception safety and traits support - this
                    is where expertise transcends isolated knowledge and becomes engineering judgment.
                </p>
            </article>
        </div>
    </section>
</main>
<footer>
    Yurii Cherkasov &copy; 2025
</footer>
<script src="./index.js"></script>
</body>
</html>
